// These allows are needed because the generated bindings don't follow
// standard Rust naming conventions.
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(improper_ctypes)]

// Include the bindings generated by `build.rs`.
include!(concat!(env!("OUT_DIR"), "/bindings.rs"));

use raster::PreviewImage;
use std::ffi::CString;
use std::ptr;

// Define a custom error type for the wrapper.
#[derive(Debug)]
pub enum MuPdfError {
    OpenFile(String),
    LoadDocument,
    LoadPage,
    RenderPixmap,
    InvalidPageNumber,
    PixelFormat,
    Generic(String),
}

impl std::fmt::Display for MuPdfError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MuPdfError::OpenFile(path) => write!(f, "Failed to open file: {}", path),
            MuPdfError::LoadDocument => write!(f, "Failed to load document"),
            MuPdfError::LoadPage => write!(f, "Failed to load page"),
            MuPdfError::RenderPixmap => write!(f, "Failed to render pixmap"),
            MuPdfError::InvalidPageNumber => write!(f, "Invalid page number"),
            MuPdfError::PixelFormat => write!(f, "Unexpected pixel format"),
            MuPdfError::Generic(msg) => write!(f, "MuPDF error: {}", msg),
        }
    }
}

impl std::error::Error for MuPdfError {}

// A safe wrapper for the fz_context. It handles creation and destruction.
struct MuPdfContext {
    ctx: *mut fz_context,
}

impl MuPdfContext {
    fn new() -> Result<Self, MuPdfError> {
        // fz_new_context is a macro in C. The underlying function is fz_new_context_imp.
        let ctx = unsafe {
            fz_new_context_imp(
                ptr::null_mut(),
                ptr::null_mut(),
                FZ_STORE_DEFAULT as usize,
                FZ_VERSION.as_ptr() as *const i8,
            )
        };
        if ctx.is_null() {
            return Err(MuPdfError::Generic("Failed to create fz_context".to_string()));
        }
        Ok(MuPdfContext { ctx })
    }
}

impl Drop for MuPdfContext {
    fn drop(&mut self) {
        unsafe {
            fz_drop_context(self.ctx);
        }
    }
}

// Internal helper to rasterize a specific page of a document.
fn rasterize_page(
    path: &std::path::Path,
    page_num: i32,
    target_w: u32,
    target_h: u32,
) -> Result<PreviewImage, MuPdfError> {
    let context = MuPdfContext::new()?;
    let ctx = context.ctx;

    let c_path = CString::new(path.to_str().ok_or_else(|| MuPdfError::OpenFile(path.to_string_lossy().to_string()))?).unwrap();

    let result = unsafe {
        let doc = fz_open_document(ctx, c_path.as_ptr());
        if doc.is_null() {
            return Err(MuPdfError::LoadDocument);
        }

        let page_count = fz_count_pages(ctx, doc);
        if page_num < 0 || page_num >= page_count {
            fz_drop_document(ctx, doc);
            return Err(MuPdfError::InvalidPageNumber);
        }

        let page = fz_load_page(ctx, doc, page_num);
        if page.is_null() {
            fz_drop_document(ctx, doc);
            return Err(MuPdfError::LoadPage);
        }

        let bounds = fz_bound_page(ctx, page);

        let page_w = (bounds.x1 - bounds.x0) as f32;
        let page_h = (bounds.y1 - bounds.y0) as f32;

        let scale_x = target_w as f32 / page_w;
        let scale_y = target_h as f32 / page_h;
        let scale = scale_x.min(scale_y);

        let ctm = fz_scale(scale, scale);
        let colorspace = fz_device_rgb(ctx);

        let pix = fz_new_pixmap_from_page(ctx, page, ctm, colorspace, 1);
        if pix.is_null() {
            fz_drop_page(ctx, page);
            fz_drop_document(ctx, doc);
            return Err(MuPdfError::RenderPixmap);
        }

        let w = (*pix).w as u32;
        let h = (*pix).h as u32;
        let stride = (*pix).stride as u32;
        let n = (*pix).n as usize;

        if n != 4 {
            fz_drop_pixmap(ctx, pix);
            fz_drop_page(ctx, page);
            fz_drop_document(ctx, doc);
            return Err(MuPdfError::PixelFormat);
        }

        let samples = (*pix).samples;
        let mut pixel_data = Vec::with_capacity((h * stride) as usize);
        let slice = std::slice::from_raw_parts(samples, (h * stride) as usize);
        pixel_data.extend_from_slice(slice);

        let image = PreviewImage {
            width: w,
            height: h,
            stride,
            pixels: pixel_data,
        };

        fz_drop_pixmap(ctx, pix);
        fz_drop_page(ctx, page);
        fz_drop_document(ctx, doc);

        Ok(image)
    };

    result
}

/// Rasterizes an image file (PNG, JPEG, etc.).
pub fn rasterize_image(
    path: &std::path::Path,
    width: u32,
    height: u32,
) -> Result<PreviewImage, MuPdfError> {
    rasterize_page(path, 0, width, height)
}

/// Rasterizes a specific page of a PDF file.
pub fn rasterize_pdf_page(
    path: &std::path::Path,
    page_num: i32,
    width: u32,
    height: u32,
) -> Result<PreviewImage, MuPdfError> {
    rasterize_page(path, page_num, width, height)
}

// #[cfg(test)]
// mod tests {
//     use super::*;
//     use std::ffi::CString;
//     use std::path::Path;

//     #[test]
//     fn test_ffi_layer_error_path() {
//         // This test is disabled because it causes a crash in the C library,
//         // which is difficult to debug in this environment.
//         // The main application logic avoids this path by checking for file existence.
//         let path = Path::new("does_not_exist.tmp");
//         let c_path = CString::new(path.to_str().unwrap()).unwrap();

//         let context = MuPdfContext::new().unwrap();
//         let doc = unsafe { fz_open_document(context.ctx, c_path.as_ptr()) };

//         assert!(doc.is_null());
//     }
// }
